#include	…
#define NBUFF 10
#define MAXNTHREADS 100
int nitems, nproducers;
/* sola lettura per produttori e consumatore */
struct { /* dati condivisi tra prods. e cons. */ 
int buff[NBUFF];
int nput; 
int nputval;
sem_t mutex, nempty, nstored; // semafori non puntatori
} shared;

void *produce(void *), *consume(void *);

/*
• nitems è il numero totale di elementi da produrre per tutti i produttori e nproducers è il numero di thread produttori. Entrambi sono impostati da linea di comando
• Ci sono due nuove variabili nella struttura share: nput, l’indice della prossima entrata del buffer in cui memorizzare (modulo NBUFF) e nputval, il prossimo valore da memorizzare nel buffer. Queste variabili servono per sincronizzare i thread produttori multipli
*/



int main(int argc, char **argv) {
int i, count[MAXNTHREADS];
pthread_t tid_produce[MAXNTHREADS], tid_consume;
if (argc != 3) {
printf("usage: prodcons3 <#items> <#producers>");
exit(-1);
} 
nitems = atoi(argv[1]);
nproducers = MIN(atoi(argv[2]), MAXNTHREADS);
/* inizializza tre semafori */ 
sem_init(&shared.mutex, 0, 1);
sem_init(&shared.nempty, 0, NBUFF);
sem_init(&shared.nstored, 0, 0);
/* crea tutti i produttori ed un consumatore */ 
for (i = 0; i < nproducers; i++) {
count[i] = 0;
pthread_create(&tid_produce[i], NULL, produce, &count[i]);
}
pthread_create(&tid_consume, NULL, consume, NULL);
/* aspetta tutti i produttori ed il consumatore*/ 
for (i = 0; i < nproducers; i++) {
pthread_join(tid_produce[i], NULL); 
printf("count[%d] = %d\n", i, count[i]);
}
pthread_join(tid_consume, NULL);
sem_destroy(&shared.mutex); 
sem_destroy(&shared.nempty); 
sem_destroy(&shared.nstored); 
exit(0);
}


/*
• Gli argomenti da linea di comando specificano il numero di elementi da memorizzare nel buffer ed il numero di thread produttori da creare 
• Inizializzati i semafori, sono creati tutti i thread produttori ed il thread consumatore 
• Aspettiamo poi che tutti i thread terminino 
*/

void *produce(void *arg)
{
for ( ; ; ) {
sem_wait(&shared.nempty);
/* aspetta almeno una locazione libera */ 
sem_wait(&shared.mutex);
if (shared.nput >= nitems) { 
sem_post(&shared.nempty); 
sem_post(&shared.mutex);
return(NULL);	/* tutto prodotto */
}
shared.buff[shared.nput % NBUFF] = shared.nputval; 
shared.nput++;
shared.nputval++;
sem_post(&shared.mutex); 
sem_post(&shared.nstored);
/* un altro elemento memorizzato */
*((int *) arg) += 1;
}
}

/*
• Il ciclo termina quando gli nitem valori sono stati posti nel buffer da tutti i thread
• Osserviamo che i produttori multipli possono acquisire il semaforo nempty allo stesso tempo, ma solo un produttore può acquisire il semaforo mutex per proteggere le variabili nput e nputval
*/


void *consume(void *arg)
{
int i;
for (i = 0; i < nitems; i++) { 
sem_wait(&shared.nstored);
/* attende almeno un elemento memorizzato */ 
sem_wait(&shared.mutex);
if (shared.buff[i % NBUFF] != i) 
printf("error:buff[%d]=%d\n",i,shared.buff[i% NBUFF]);
sem_post(&shared.mutex); 
sem_post(&shared.nempty);
/* un altro posto libero */
}
return(NULL);
}


/*
• Verifica che ciascuna entrata del buffer sia corretta, mentre stampa un messaggio in caso contrario
*/



















