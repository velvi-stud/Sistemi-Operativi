/* 
Vogliamo dimostrare che i mutex sono appropriati per il
locking e non altrettanto per il waiting (attesa)
•Modifichiamo l’esempio del produttore-consumatore precedente ed avviamo il thread consumatore appena dopo che i thread produttori sono stati avviati
•Ciò consente al consumatore di elaborare i dati non appena questi sono generati dai produttori
•Dobbiamo sincronizzare il consumatore con i produttori per essere certi che il consumatore elabori solo i dati che sono già stati memorizzati dai produttori
*/

int main(int argc, char **argv)
{
int i, nthreads, count[MAXNTHREADS]; 
pthread_t tid_produce[MAXNTHREADS], tid_consume; 
if (argc != 3){
printf("usage: prodcons2 <#items> <#threads>");
exit(-1);
} 
nitems = MIN(atoi(argv[1]), MAXNITEMS);
nthreads = MIN(atoi(argv[2]), MAXNTHREADS);
for (i = 0; i < nthreads; i++) { 
count[i] = 0;
pthread_create(&tid_produce[i], NULL, produce, &count[i]);
}
pthread_create(&tid_consume, NULL, consume, NULL);
/* aspetta tutti i produttori e il consumatore */ 
for (i = 0; i < nthreads; i++) {
pthread_join(tid_produce[i], NULL); 
printf("count[%d] = %d\n", i, count[i]);
}
pthread_join(tid_consume, NULL);
exit(0);
}

/*
•Il consumatore deve aspettare
•La funzione consume chiama consume_wait prima di prelevare il prossimo elemento dall’array
•La funzione consume_wait deve attendere fino a che i produttori hanno generato l’i-esimo elemento
•Per controllare questa condizione, il mutex del produttore è bloccato ed i è confrontato con l’indice nput del produttore
•Dobbiamo acquisire il blocco del mutex prima di controllare nput poiché questa variabile può essere in corso di aggiornamento da uno dei thread produttori
*/

void *produce(void *arg)
{
for ( ; ; ) { 
pthread_mutex_lock(&shared.mutex); 
if (shared.nput >= nitems) {
pthread_mutex_unlock(&shared.mutex); 
return(NULL);	/* array pieno */
}
shared.buff[shared.nput] = shared.nval; 
shared.nput++;
shared.nval++; 
pthread_mutex_unlock(&shared.mutex);
*((int *) arg) += 1;
}
}


void consume_wait(int i)
{
for ( ; ; ) {
pthread_mutex_lock(&shared.mutex); 
if (i < shared.nput) {
pthread_mutex_unlock(&shared.mutex); 
return;	/* un elemento è pronto */
}
pthread_mutex_unlock(&shared.mutex);
}
}
void * consume(void *arg)
{
int i;
for (i = 0; i < nitems; i++) { 
consume_wait(i);
if (shared.buff[i] != i)
printf("buff[%d] = %d\n", i, shared.buff[i]);
}
return(NULL);
}

/*
•La questione fondamentale è: cosa possiamo fare quando l’elemento non è disponibile?
•Effettuiamo un ciclo sbloccando e bloccando il mutex ogni volta
•Questa operazione è denominata polling e comporta un notevole spreco di tempo di CPU
•Abbiamo bisogno di un altro tipo di sincronizzazione che consenta ai thread di dormire fino a che si verifichi qualche evento
BISOGNA MIGLIORARLO
*/



