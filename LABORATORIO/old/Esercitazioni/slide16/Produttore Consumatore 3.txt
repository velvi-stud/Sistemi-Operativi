/*
•Illustriamo l’uso delle variabili condizione modificando il codice del produttore-consumatore visto in precedenza
•Le due variabili nput ed nval sono associate con il mutex, e mettiamo tutte e tre le variabili in una struttura chiamata put
•struttura usata dai produttori
•L’altra struttura, nready, contiene un contatore, una variabile condizione e un mutex. Inizializziamo la variabile condizione a PTHREAD_COND_INIZIALIZER
*/

#include	…
#define	MAXNITEMS	1000000
#define	MAXNTHREADS	100

/* globali condivise dai thread */
int nitems;
int buff[MAXNITEMS];
struct {
pthread_mutex_t mutex;
int nput; // indice successivo in cui memorizzare
int nval; // valore successivo da memorizzare
} put = { PTHREAD_MUTEX_INITIALIZER };
struct {
pthread_mutex_t mutex; 
pthread_cond_t	cond;
int nready;// numero a disposizione del cons.
} nready = { PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER};
/* fine globali */

void *produce(void *), *consume(void *);

int main(int argc, char **argv)
{
int i, nthreads, count[MAXNTHREADS]; 
pthread_t tid_produce[MAXNTHREADS], tid_consume; 
if (argc != 3){
printf("usage: prodcons3 <#items> <#threads>");
exit(-1);
} 
nitems = MIN(atoi(argv[1]), MAXNITEMS);
nthreads = MIN(atoi(argv[2]), MAXNTHREADS);
/* crea tutti i produttori ed un consumatore */ 
for (i = 0; i < nthreads; i++) {
count[i] = 0;
pthread_create(&tid_produce[i], NULL, produce, &count[i]);
}
pthread_create(&tid_consume, NULL, consume, NULL);
/* aspetta tutti i produttori ed il consumatore */ 
for (i = 0; i < nthreads; i++) {
pthread_join(tid_produce[i], NULL); 
printf("count[%d] = %d\n", i, count[i]);
}
pthread_join(tid_consume, NULL); 
exit(0);
}


void *produce(void *arg){
for ( ; ; ) {
pthread_mutex_lock(&put.mutex); 
if (put.nput >= nitems) {
pthread_mutex_unlock(&put.mutex); 
return(NULL);	/* array pieno */
}
buff[put.nput] = put.nval; 
put.nput++;
put.nval++; 
pthread_mutex_unlock(&put.mutex);

pthread_mutex_lock(&nready.mutex); 
if (nready.nready == 0)
pthread_cond_signal(&nready.cond); 
nready.nready++; 
pthread_mutex_unlock(&nready.mutex);
*((int *) arg) += 1;
}
}


/*
•Usiamo il mutex put.mutex per bloccare la sezione critica quando il produttore pone un nuovo elemento nell’array
•Incrementiamo il contatore nready.nready che conta il numero di elementi pronti per il thread consumatore
•Prima dell’incremento, se il valore del contatore era 0, chiamiamo pthread_cond_signal per risvegliare un qualsiasi thread (l’unico consumatore) in attesa che tale valore diventi diverso da 0
•Possiamo vedere l’interazione del mutex e della variabile condizione associati al contatore (nready)
•Il contatore è condiviso tra i produttori e il consumatore quindi l’accesso deve avvenire quando il mutex associato (nready.mutex) è bloccato
•La variabile condizione è usata per aspettare e segnalare
*/


void *consume(void *arg)
{
int i;
for (i = 0; i < nitems; i++) { 
pthread_mutex_lock(&nready.mutex); 
while (nready.nready == 0)
pthread_cond_wait(&nready.cond, &nready.mutex); 
nready.nready--; 
pthread_mutex_unlock(&nready.mutex);
if (buff[i] != i)
printf("buff[%d] = %d\n", i, buff[i]);
}
return(NULL);
}

/*
•Il consumatore aspetta che nready.nready sia diverso da zero
•Poiché esso è condiviso tra i produttori ed il consumatore, possiamo testare il suo valore solo mentre il mutex associato è bloccato
•Se, mentre il mutex è bloccato, il valore è 0, chiamiamo pthread_cond_wait() per attendere. Ciò effettua due azioni in modo atomico:
•Il mutex nready.mutex è sbloccato e
•Il thread è messo in attesa fino a che qualche altro thread chiama pthread_cond_signal() per questa variabile condizione
*/


/*
•Prima di ritornare, phtread_cond_wait blocca il mutex nready.mutex
•quando ritorna e troviamo che il contatore è diverso da zero, decrementiamo il contatore (sapendo che il mutex è bloccato) e poi sblocchiamo il mutex
•In questa implementazione, la variabile che mantiene la condizione è un contatore intero e l’impostazione della condizione è semplicemente l’incremento del contatore
•In questo caso si è ottimizzato il codice in modo che il segnale si verifica solo quando il contatore va da 0 a 1

*/
